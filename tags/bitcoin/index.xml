<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>bitcoin on </title>
    <link>/tags/bitcoin/</link>
    <description>Recent content in bitcoin on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 25 Jul 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/tags/bitcoin/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>LedgerJS</title>
      <link>/posts/bitcoin/ledger-js/</link>
      <pubDate>Sat, 25 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/bitcoin/ledger-js/</guid>
      <description>A hardware wallet is a specialized physical device used to store (and derive) your private keys. Some of the most popular products are developed by Ledger and you may be familiar with the Nano series. They support developing custom applications in C (for now, but Rust is coming) and the active library is well stocked, both Bitcoin and Ethereum have dedicated applications. To build on top of these we need to speak through the application protocol data unit (APDU) - for which Bitcoin has a technical specification.</description>
    </item>
    
    <item>
      <title>ELI5: Bitcoin Difficulty</title>
      <link>/posts/bitcoin/eli5-difficulty/</link>
      <pubDate>Mon, 13 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/bitcoin/eli5-difficulty/</guid>
      <description>In Bitcoin, difficulty is the measure of how hard it is to mine a block. To ensure constant output, this rate is adjusted every 2016 blocks - anticipating block production to take around ten minutes, we can expect recalculation every two weeks. If more blocks are produced than expected then the difficulty is increased, otherwise it is lowered.
The following formulae can be used to calculate the difficulty rate for any given height - substituting an expected average of 600 seconds (10 minutes) and a base difficulty (introduced at genesis) of 1.</description>
    </item>
    
    <item>
      <title>Containerizing Bitcoin</title>
      <link>/posts/bitcoin/docker/</link>
      <pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/bitcoin/docker/</guid>
      <description>There are over 500,000 lines of code in Bitcoin Core, roughly 70% of which is pure C++. Compile times vary, but if you just want to get a node up and running, docker is the easiest way to go. Here&amp;rsquo;s something I prepared earlier&amp;hellip;
Courtesy of the official docs, there are only four commands to run which build bitcoind, bitcoin-cli and bitcoin-qt. The dependencies are clearly outlined for different architectures - including OSx, Windows and Unix flavours - but in my Dockerfile I have chosen to extend Ubuntu.</description>
    </item>
    
    <item>
      <title>Proof of Work (Explained)</title>
      <link>/posts/bitcoin/pow_explained/</link>
      <pubDate>Sun, 22 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/bitcoin/pow_explained/</guid>
      <description>So you&amp;rsquo;ve read the theory, but want to understand Bitcoin programmatically. In this post we will analyse the core codebase written in C++ to understand how one can generate and include a block in the chain. Starting with the atomic unit of construction in this context, a block is a grouping of transactions that alter the state of the ledger. For example, a coinbase transaction may be included by a miner to collect a block reward.</description>
    </item>
    
  </channel>
</rss>