<!DOCTYPE html>
<html lang="en-gb">
    <head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">

		<title>Proof of Work (Explained) &middot; Greg Hill</title>

		
  		<link rel="stylesheet" href="/css/style.css">
		<link rel="stylesheet" href="/css/fonts.css">
		
		<link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
		<link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
		<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

		
		<link href="" rel="alternate" type="application/rss+xml" title="Greg Hill" />
	</head>

    <body>
        		<nav class="nav">
			<div class="nav-container">
				<a href="/">
					<h2 class="nav-title">Greg Hill</h2>
				</a>
				<ul>
    
    
        <li>
            <a href="/posts/">
                
                <span>Posts</span>
                
            </a>
        </li>
    
        <li>
            <a href="/projects/">
                
                <span>Projects</span>
                
            </a>
        </li>
    
</ul>
			</div>
		</nav>

        

<main>
	<div class="post">
		<div class="post-info">
    <span>Written by</span>
        Gregory Hill
        <br>
        <span>on&nbsp;</span><time datetime="2019-12-22 00:00:00 &#43;0000 UTC">December 22, 2019</time>
</div>
		<h1 class="post-title">Proof of Work (Explained)</h1>
<div class="post-line"></div>

		

		<p>So you&rsquo;ve read the theory, but want to understand Bitcoin programmatically. In this post we will analyse the
core codebase written in C++ to understand how one can generate and include a block in the chain. Starting with
the atomic unit of construction in this context, a block is a grouping of transactions that alter the state of
the ledger. For example, a <code>coinbase</code> transaction may be included by a miner to collect a block reward. But in
order for these to be processed by the network, a miner must provide a proof of work for the serialization of
the following fields:</p>
<ul>
<li><code>nVersion</code></li>
<li><code>hashPrevBlock</code></li>
<li><code>hashMerkleRoot</code></li>
<li><code>nTime</code></li>
<li><code>nBits</code></li>
<li><code>nNonce</code></li>
</ul>
<p>The class definition of a block header is shown in the following snippet, of particular interest is <code>SerializationOp</code>
which tells the compiler how an instance of this class should be serialized and <code>GetHash</code> which returns a 256-bit
unsigned integer.</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>The implementation of <code>GetHash</code> calls another function <code>SerializeHash</code> passing a dereferenced pointer to its context.</p>
<!-- raw HTML omitted -->
<p>From here, <code>CHashWriter</code> is established which computes the digest via the <code>CHash256</code> class.</p>
<!-- raw HTML omitted -->
<p>We can see that <code>Finalize</code> writes and flushes the hash to the input buffer. It is important to note that
this actually computes <code>SHA-256d</code> (double) in an effort to prevent &ldquo;length-extension&rdquo; attacks.</p>
<!-- raw HTML omitted -->
<p>Assuming this process has given us a valid digest of our input, how can we convince other participants to
append our block to their view of the chain? This is where the consensus parameter <code>bnTarget</code> comes in.
For brevity, we will ignore how this is chosen but I will note that this is dynamic - the network adapts it
based on mining speeds. Honest nodes will thus accept a gossiped block under the condition that the arithmetical
representation of its hash is less that that of the current target.</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>To recompute a new hash, we need some variability in the form of <code>nNonce</code>. As there is no way to predict what input will lead to
a desired hash, all we can do is increment it. There&rsquo;s a useful example of this in the following test helper.</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>Providing the final hash meets the criteria and enough nodes know about it, subsequent miners will include it as
<code>hashPrevBlock</code> in their constructions.</p>


		
	</div>

	<div class="pagination">
		<a href="/posts/rust/table-tests/" class="left arrow">&#8592;</a>
		<a href="/posts/travel/hyperledger_gf_2020/" class="right arrow">&#8594;</a>

		<a href="#" class="top">Top</a>
	</div>
</main>


        		<footer>
			<span>
			&copy; <time datetime="2020-04-07 16:25:22.429848677 &#43;0100 BST m=&#43;0.042233776">2020</time> Greg Hill. Made with <a href='https://gohugo.io'>Hugo</a> using the <a href='https://github.com/EmielH/tale-hugo/'>Tale</a> theme.
			</span>
		</footer>

    </body>
</html>
