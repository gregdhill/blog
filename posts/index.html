<!DOCTYPE html>
<html lang="en"><head>
	<meta charset="UTF-8">
	<meta name="description" content="Interested in Blockchains, Cryptography and Distributed Systems.">
	<meta name="keywords" content="computer, security, ethical hacker, researcher, inventor, abertay, dundee, edinburgh, machine learning, mathematics, cryptography, blockchains, reverse engineering, linux, programming, scotland, greg hill">
	<meta name="author" content="Gregory Hill">
    <meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Gregory Hill | Posts</title>
	<link href="../css/style.css" rel="stylesheet">
	<link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">
	<link rel="apple-touch-icon" sizes="180x180" href="../img/apple-touch-icon.png">
	<link rel="icon" type="image/png" href="../img/favicon-32x32.png" sizes="32x32">
	<link rel="icon" type="image/png" href="../img/favicon-16x16.png" sizes="16x16">
	<link rel="manifest" href="../img/manifest.json">
	<link rel="mask-icon" href="../img/safari-pinned-tab.svg" color="#5bbad5">
	<link rel="shortcut icon" href="../img/favicon.ico">
	<meta name="msapplication-config" content="/img/browserconfig.xml">
	<meta name="theme-color" content="#ffffff">
</head><body>
    <main><div class="catalogue">
    <h1 class="catalogue-header">Posts</h1>
    
    <a href="../posts/key-management/" class="catalogue-item">
        <div>
            
                <time class="catalogue-time">December 31, 2020</time>
            
            <h1 class="catalogue-title">Online Key Management</h1>
    
            
                <p>I was recently looking into key management for the BTC-Parachain and associated client software. Like similar software - namely Proof-of-Stake (PoS) validators or arbitrage keepers - they are designed to run autonomously 24/7 with unrestricted access to private keys for signing. In my effort to understand best-practices I decided to compare approaches across the industry.</p>
            
        </div>
    </a>
    
    <a href="../posts/bitcoin/bip47/" class="catalogue-item">
        <div>
            
                <time class="catalogue-time">December 5, 2020</time>
            
            <h1 class="catalogue-title">BIP47: TL;DR</h1>
    
            
                <p>Reusable payment codes simplify identity management without loss of privacy.</p>
            
        </div>
    </a>
    
    <a href="../posts/bitcoin/ledger-js/" class="catalogue-item">
        <div>
            
                <time class="catalogue-time">July 25, 2020</time>
            
            <h1 class="catalogue-title">LedgerJS</h1>
    
            
                <p>A hardware wallet is a specialized physical device used to store (and derive) your private keys. Some of the most popular products are developed by Ledger and you may be familiar with the Nano series. They support developing custom applications in C (for now, but Rust is coming) and the active library is well stocked, both Bitcoin and Ethereum have dedicated applications. To build on top of these we need to speak through the application protocol data unit (APDU) - for which Bitcoin has a technical specification.</p>
            
        </div>
    </a>
    
    <a href="../posts/cosmos/interchain/" class="catalogue-item">
        <div>
            
                <time class="catalogue-time">May 25, 2020</time>
            
            <h1 class="catalogue-title">Interchain Standards</h1>
    
            
                <p>The Inter-Blockchain Communication (IBC) protocol is an architecture designed for Cosmos to allow participating processes to share state. Each module is a deterministic process, such as a replicated state machine with fast transaction finality. Unlike sharded architectures (such as Polkadot), IBC does not provide pooled security.
The specification builds on several assumptions to reason about the capabilities of the protocol. For instance, it assumes fast finality for any adopted consensus mechanism - Tendermint &amp; GRANDPA are two such examples.</p>
            
        </div>
    </a>
    
    <a href="../posts/dual-boot/" class="catalogue-item">
        <div>
            
                <time class="catalogue-time">April 25, 2020</time>
            
            <h1 class="catalogue-title">Dual Booting Windows &amp; Arch Linux</h1>
    
            
                <p>Having spent far too much time reinstalling my desktop this weekend, I thought it best to write up the process.
Before continuing, boot into the machine’s BIOS to enable UEFI booting and disable Secure Boot.
Windows 10  Download the latest image and install it on a flash drive. Ensure that the machine boots with this flash drive in UEFI mode. Follow the wizard and delete all existing partitions. Create a new partition for Windows, leaving suitable unallocated space for Linux.</p>
            
        </div>
    </a>
    
    <a href="../posts/bitcoin/eli5-difficulty/" class="catalogue-item">
        <div>
            
                <time class="catalogue-time">April 13, 2020</time>
            
            <h1 class="catalogue-title">ELI5: Bitcoin Difficulty</h1>
    
            
                <p>In Bitcoin, difficulty is the measure of how hard it is to mine a block. To ensure constant output, this rate is adjusted every 2016 blocks - anticipating block production to take around ten minutes, we can expect recalculation every two weeks. If more blocks are produced than expected then the difficulty is increased, otherwise it is lowered.
The following formulae can be used to calculate the difficulty rate for any given height - substituting an expected average of 600 seconds (10 minutes) and a base difficulty (introduced at genesis) of 1.</p>
            
        </div>
    </a>
    
    <a href="../posts/ethereum/ens-ipfs/" class="catalogue-item">
        <div>
            
                <time class="catalogue-time">April 11, 2020</time>
            
            <h1 class="catalogue-title">ENS &amp; IPFS</h1>
    
            
                <p>By utilizing the Ethereum Name Service (ENS) for resolution and the Interplanetary File System (IPFS) for content hosting it is possible to decentralize a static website while retaining the predictable URL.
My primary setup leverages GitHub pages to host a blog compiled with Hugo - linked to my domain name. Whenever I want to publish a change, I build the latest website from my markdown content using my custom theme and push it to a separate branch in my personal repository.</p>
            
        </div>
    </a>
    
    <a href="../posts/bitcoin/docker/" class="catalogue-item">
        <div>
            
                <time class="catalogue-time">April 10, 2020</time>
            
            <h1 class="catalogue-title">Containerizing Bitcoin</h1>
    
            
                <p>There are over 500,000 lines of code in Bitcoin Core, roughly 70% of which is pure C++. Compile times vary, but if you just want to get a node up and running, docker is the easiest way to go. Here’s something I prepared earlier…
Courtesy of the official docs, there are only four commands to run which build bitcoind, bitcoin-cli and bitcoin-qt. The dependencies are clearly outlined for different architectures - including OSx, Windows and Unix flavours - but in my Dockerfile I have chosen to extend Ubuntu.</p>
            
        </div>
    </a>
    
    <a href="../posts/substrate/introduction/" class="catalogue-item">
        <div>
            
                <time class="catalogue-time">April 8, 2020</time>
            
            <h1 class="catalogue-title">Substrate &amp; Ink</h1>
    
            
                <p>To interact with Polkadot, there are three envisioned development trajectories; a parachain implements it’s own runtime logic (think custom sidechain), a parathread is similar but only produces a block when absolutely necessary to update the relay chain, and a smart contract can run atop any chain with the correct execution environment. Substrate enables the former methodology based on a modular architecture with pluggable consensus and Parity maintain an embedded Domain Specific Language (eDSL) atop Substrate for WASM smart contracts.</p>
            
        </div>
    </a>
    
    <a href="../posts/ethereum/proxy-contracts/" class="catalogue-item">
        <div>
            
                <time class="catalogue-time">April 6, 2020</time>
            
            <h1 class="catalogue-title">Upgradable Proxy Contracts</h1>
    
            
                <p>Smart contracts in Ethereum are immutable; once they have been included in a block they cannot be changed. This is a weird philosophy to adopt from a software engineering perspective. What if there are bugs in your code? Solidity has a plethora of known attacks which, given the economical value at risk, is troubling to say the least. However, we also do not want to interact with an unstable application that can be arbitrarily updated.</p>
            
        </div>
    </a>
    
</div>

<div class="pagination">
    
    
        <a href="../posts/page/2/" class="right arrow">
            <i class="grow fa fa-long-arrow-right fa-1x" aria-hidden="true"></i>
        </a>
    

    <span>1</span>
</div>

</main>
</body></html>