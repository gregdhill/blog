<!DOCTYPE html>
<html lang="en"><head>
	<meta charset="UTF-8">
	<meta name="description" content="Interested in Blockchains, Cryptography and Distributed Systems.">
	<meta name="keywords" content="computer, security, ethical hacker, researcher, inventor, abertay, dundee, edinburgh, machine learning, mathematics, cryptography, blockchains, reverse engineering, linux, programming, scotland, greg hill">
	<meta name="author" content="Gregory Hill">
    <meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Gregory Hill | Posts</title>
	<link href="../css/style.css" rel="stylesheet">
	<link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">
	<link rel="apple-touch-icon" sizes="180x180" href="../img/apple-touch-icon.png">
	<link rel="icon" type="image/png" href="../img/favicon-32x32.png" sizes="32x32">
	<link rel="icon" type="image/png" href="../img/favicon-16x16.png" sizes="16x16">
	<link rel="manifest" href="../img/manifest.json">
	<link rel="mask-icon" href="../img/safari-pinned-tab.svg" color="#5bbad5">
	<link rel="shortcut icon" href="../img/favicon.ico">
	<meta name="msapplication-config" content="/img/browserconfig.xml">
	<meta name="theme-color" content="#ffffff">
</head><body>
    <main><div class="catalogue">
    <h1 class="catalogue-header">Posts</h1>
    
    <a href="../posts/cosmos/interchain/" class="catalogue-item">
        <div>
            
                <time class="catalogue-time">May 25, 2020</time>
            
            <h1 class="catalogue-title">Interchain Standards</h1>
    
            
                <p>The Inter-Blockchain Communication (IBC) protocol is an architecture designed for Cosmos to allow participating processes to share state. Each module is a deterministic process, such as a replicated state machine with fast transaction finality. Unlike sharded architectures (such as Polkadot), IBC does not provide pooled security.
The specification builds on several assumptions to reason about the capabilities of the protocol. For instance, it assumes fast finality for any adopted consensus mechanism - Tendermint &amp; GRANDPA are two such examples.</p>
            
        </div>
    </a>
    
    <a href="../posts/dual-boot/" class="catalogue-item">
        <div>
            
                <time class="catalogue-time">April 25, 2020</time>
            
            <h1 class="catalogue-title">Dual Booting Windows &amp; Arch Linux</h1>
    
            
                <p>Having spent far too much time reinstalling my desktop this weekend, I thought it best to write up the process.
Before continuing, boot into the machine’s BIOS to enable UEFI booting and disable Secure Boot.
Windows 10  Download the latest image and install it on a flash drive. Ensure that the machine boots with this flash drive in UEFI mode. Follow the wizard and delete all existing partitions. Create a new partition for Windows, leaving suitable unallocated space for Linux.</p>
            
        </div>
    </a>
    
    <a href="../posts/bitcoin/eli5-difficulty/" class="catalogue-item">
        <div>
            
                <time class="catalogue-time">April 13, 2020</time>
            
            <h1 class="catalogue-title">ELI5: Bitcoin Difficulty</h1>
    
            
                <p>In Bitcoin, difficulty is the measure of how hard it is to mine a block. To ensure constant output, this rate is adjusted every 2016 blocks - anticipating block production to take around ten minutes, we can expect recalculation every two weeks. If more blocks are produced than expected then the difficulty is increased, otherwise it is lowered.
The following formulae can be used to calculate the difficulty rate for any given height - substituting an expected average of 600 seconds (10 minutes) and a base difficulty (introduced at genesis) of 1.</p>
            
        </div>
    </a>
    
    <a href="../posts/ethereum/ens-ipfs/" class="catalogue-item">
        <div>
            
                <time class="catalogue-time">April 11, 2020</time>
            
            <h1 class="catalogue-title">ENS &amp; IPFS</h1>
    
            
                <p>By utilizing the Ethereum Name Service (ENS) for resolution and the Interplanetary File System (IPFS) for content hosting it is possible to decentralize a static website while retaining the predictable URL.
My primary setup leverages GitHub pages to host a blog compiled with Hugo - linked to my domain name. Whenever I want to publish a change, I build the latest website from my markdown content using my custom theme and push it to a separate branch in my personal repository.</p>
            
        </div>
    </a>
    
    <a href="../posts/bitcoin/docker/" class="catalogue-item">
        <div>
            
                <time class="catalogue-time">April 10, 2020</time>
            
            <h1 class="catalogue-title">Containerizing Bitcoin</h1>
    
            
                <p>There are over 500,000 lines of code in Bitcoin Core, roughly 70% of which is pure C++. Compile times vary, but if you just want to get a node up and running, docker is the easiest way to go. Here’s something I prepared earlier…
Courtesy of the official docs, there are only four commands to run which build bitcoind, bitcoin-cli and bitcoin-qt. The dependencies are clearly outlined for different architectures - including OSx, Windows and Unix flavours - but in my Dockerfile I have chosen to extend Ubuntu.</p>
            
        </div>
    </a>
    
    <a href="../posts/substrate/introduction/" class="catalogue-item">
        <div>
            
                <time class="catalogue-time">April 8, 2020</time>
            
            <h1 class="catalogue-title">Substrate &amp; Ink</h1>
    
            
                <p>To interact with Polkadot, there are three envisioned development trajectories; a parachain implements it’s own runtime logic (think custom sidechain), a parathread is similar but only produces a block when absolutely necessary to update the relay chain, and a smart contract can run atop any chain with the correct execution environment. Substrate enables the former methodology based on a modular architecture with pluggable consensus and Parity maintain an embedded Domain Specific Language (eDSL) atop Substrate for WASM smart contracts.</p>
            
        </div>
    </a>
    
    <a href="../posts/ethereum/proxy-contracts/" class="catalogue-item">
        <div>
            
                <time class="catalogue-time">April 6, 2020</time>
            
            <h1 class="catalogue-title">Upgradable Proxy Contracts</h1>
    
            
                <p>Smart contracts in Ethereum are immutable; once they have been included in a block they cannot be changed. This is a weird philosophy to adopt from a software engineering perspective. What if there are bugs in your code? Solidity has a plethora of known attacks which, given the economical value at risk, is troubling to say the least. However, we also do not want to interact with an unstable application that can be arbitrarily updated.</p>
            
        </div>
    </a>
    
    <a href="../posts/travel/hyperledger_gf_2020/" class="catalogue-item">
        <div>
            
                <time class="catalogue-time">March 25, 2020</time>
            
            <h1 class="catalogue-title">Hyperledger Global Forum (2020)</h1>
    
            
                <p>Since I am on lock-down due to the ongoing coronavirus pandemic I decided this would be a good time to write up some notes from my recent visit to Phoenix, Arizona. The conference lasted around four days, though I had some buffer around this for travel - with time to visit the local desert botanical gardens! Fortunately, it was still well attended despite the obvious health concerns but the Linux Foundation made every effort to accommodate guests.</p>
            
        </div>
    </a>
    
    <a href="../posts/bitcoin/pow_explained/" class="catalogue-item">
        <div>
            
                <time class="catalogue-time">December 22, 2019</time>
            
            <h1 class="catalogue-title">Proof of Work (Explained)</h1>
    
            
                <p>So you’ve read the theory, but want to understand Bitcoin programmatically. In this post we will analyse the core codebase written in C++ to understand how one can generate and include a block in the chain. Starting with the atomic unit of construction in this context, a block is a grouping of transactions that alter the state of the ledger. For example, a coinbase transaction may be included by a miner to collect a block reward.</p>
            
        </div>
    </a>
    
    <a href="../posts/rust/table-tests/" class="catalogue-item">
        <div>
            
                <time class="catalogue-time">October 6, 2019</time>
            
            <h1 class="catalogue-title">Table Driven Tests</h1>
    
            
                <p>One of my favorite ways to write tests in Go is with a table driven test. If you are unfamiliar with the concept check out the excellent Dave Cheney post. If you need to unit test a component under a multitude of edge cases, then this is good technique to adopt. Anyway, I’m learning Rust in my spare time so I thought I’d best give it a go. Hopefully this will suffice, but if you think it could be improved please hit me up on twitter.</p>
            
        </div>
    </a>
    
</div>

<div class="pagination">
    
    
        <a href="../posts/page/2/" class="right arrow">
            <i class="grow fa fa-long-arrow-right fa-1x" aria-hidden="true"></i>
        </a>
    

    <span>1</span>
</div>

</main>
</body></html>