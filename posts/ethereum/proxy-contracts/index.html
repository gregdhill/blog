<!DOCTYPE html>
<html lang="en"><head>
	<meta charset="UTF-8">
	<meta name="description" content="Interested in Blockchains, Cryptography and Distributed Systems.">
	<meta name="keywords" content="computer, security, ethical hacker, researcher, inventor, abertay, dundee, edinburgh, machine learning, mathematics, cryptography, blockchains, reverse engineering, linux, programming, scotland, greg hill">
	<meta name="author" content="Gregory Hill">
    <meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Gregory Hill | Upgradable Proxy Contracts</title>
	<link href="/css/style.css" rel="stylesheet">
	<link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">
	<link rel="apple-touch-icon" sizes="180x180" href="/img/apple-touch-icon.png">
	<link rel="icon" type="image/png" href="img/favicon-32x32.png" sizes="32x32">
	<link rel="icon" type="image/png" href="img/favicon-16x16.png" sizes="16x16">
	<link rel="manifest" href="/img/manifest.json">
	<link rel="mask-icon" href="/img/safari-pinned-tab.svg" color="#5bbad5">
	<link rel="shortcut icon" href="/img/favicon.ico">
	<meta name="msapplication-config" content="/img/browserconfig.xml">
	<meta name="theme-color" content="#ffffff">
</head><body>
    <main><div class="post">
    <div class="post-info">
        
            Apr 6, 2020
            · 568 words
            · 3 minute read
        
    </div>

    <h1 class="post-title">
        Upgradable Proxy Contracts
    </h1>

    <div class="post-tags"><a class="tag" href=/tags/ethereum/>#ethereum</a><a class="tag" href=/tags/solidity/>#solidity</a></div>

    <p>Smart contracts in Ethereum are immutable; once they have been included in a block they cannot be changed. This is a weird philosophy to adopt from a software engineering perspective. What if there are bugs in your code? Solidity has a <a href="https://consensys.github.io/smart-contract-best-practices/known_attacks/">plethora of known attacks</a> which, given the economical value at risk, is troubling to say the least. However, we also do not want to interact with an unstable application that can be arbitrarily updated.</p>
<p>One of the more impressive concepts that I learned recently regards the decoupling of state and functionality. By separating <em>what</em> a contract stores from <em>how</em> it accesses it we can easily upgrade a contract on chain. Using the infamous DAO hack as an example, let&rsquo;s assume we have a smart contract which stores an amount of funds but also suffers from the reentrancy bug. Without changing the underlying state, we want to rewire the logic to prevent it from being exploited. Additionally, we may not want to force the original consumers to use a new (pre-initialized) contract.</p>
<p>Before getting into the details, we first need to understand the difference between <code>CALL</code> and <code>DELEGATECALL</code>. If we call a class method in the traditional sense, then we only expect it to alter it&rsquo;s own internal state (omitting arguments). Conversely, if something is delegated then we entrust someone to carry out a task on our behalf. These concepts naturally extend to Ethereum; if we delegate a call we ask a contract to operate on our state instead of it&rsquo;s own.</p>
<p>In the following example I have defined two contracts; <code>Setter</code> exposes a method to directly alter it&rsquo;s state through the <code>set</code> function, and <code>Getter</code> contains the two forward calls described above. Notice the calling <code>set</code> or <code>call</code> will alter the <code>value</code> stored in <code>Setter</code>, whereas <code>delegatecall</code> will update the <code>value</code> in <code>Getter</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-solidity" data-lang="solidity"><span style="color:#66d9ef">pragma solidity</span> <span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">0</span>;

<span style="color:#66d9ef">contract</span> Setter {
    <span style="color:#66d9ef">uint</span> <span style="color:#66d9ef">public</span> value;
    
    <span style="color:#66d9ef">function</span> set(<span style="color:#66d9ef">uint256</span> _value) <span style="color:#66d9ef">external</span> {
        value <span style="color:#f92672">=</span> _value;
    }
}

<span style="color:#66d9ef">contract</span> Getter {
    <span style="color:#66d9ef">uint</span> <span style="color:#66d9ef">public</span> value;
    
    <span style="color:#66d9ef">function</span> call(<span style="color:#66d9ef">address</span> setter, <span style="color:#66d9ef">uint256</span> value) <span style="color:#66d9ef">public</span> {
        setter.call(abi.encodeWithSignature(<span style="color:#e6db74">&#34;set(uint256)&#34;</span>, value));
    }
    
    <span style="color:#66d9ef">function</span> delegatecall(<span style="color:#66d9ef">address</span> setter, <span style="color:#66d9ef">uint256</span> value) <span style="color:#66d9ef">public</span> {
        setter.delegatecall(abi.encodeWithSignature(<span style="color:#e6db74">&#34;set(uint256)&#34;</span>, value));
    }
}
</code></pre></div><p>Another feature of Solidity that we will utilise is known as the fallback function. This unnamed function cannot take any arguments and is not able to return anything, but will run instead if the called function is not found - suitable for a proxy.</p>
<p>The proxy technique was first popularized by Nick Johnson of the Ethereum Foundation <a href="https://gist.github.com/Arachnid/4ca9da48d51e23e5cfe0f0e14dd6318f">here</a>. The basic idea is that the proxy extends the same storage layout but would forward any and all calls to the registered logic contract.</p>
<p>In this example, we first deploy the proxy and then register either of the two functional contracts to update the <code>value</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-solidity" data-lang="solidity"><span style="color:#66d9ef">contract</span> Storage {
    <span style="color:#66d9ef">uint</span> <span style="color:#66d9ef">public</span> value <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#66d9ef">contract</span> Proxy <span style="color:#66d9ef">is</span> Storage {
    <span style="color:#66d9ef">address</span> <span style="color:#66d9ef">internal</span> proxied;

    <span style="color:#66d9ef">function</span> redirect(<span style="color:#66d9ef">address</span> _proxied) <span style="color:#66d9ef">public</span> {
        proxied <span style="color:#f92672">=</span> _proxied;
    }

    <span style="color:#66d9ef">function</span> () <span style="color:#66d9ef">external</span> <span style="color:#66d9ef">payable</span> {
        <span style="color:#66d9ef">address</span> addr <span style="color:#f92672">=</span> proxied;
        <span style="color:#66d9ef">assembly</span> {
            <span style="color:#f92672">let</span> freememstart <span style="color:#f92672">:=</span> <span style="color:#a6e22e">mload</span>(<span style="color:#ae81ff">0x40</span>)
            <span style="color:#a6e22e">calldatacopy</span>(freememstart, <span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">calldatasize</span>())
            <span style="color:#f92672">let</span> success <span style="color:#f92672">:=</span> <span style="color:#a6e22e">delegatecall</span>(<span style="color:#a6e22e">not</span>(<span style="color:#ae81ff">0</span>), addr, freememstart, <span style="color:#a6e22e">calldatasize</span>(), freememstart, <span style="color:#ae81ff">32</span>)
            <span style="color:#a6e22e">switch</span> success
            case <span style="color:#ae81ff">0</span> { <span style="color:#a6e22e">revert</span>(freememstart, <span style="color:#ae81ff">32</span>) }
            default { <span style="color:#a6e22e">return</span>(freememstart, <span style="color:#ae81ff">32</span>) }
        }
    }
}

<span style="color:#66d9ef">contract</span> Addition <span style="color:#66d9ef">is</span> Storage {
    <span style="color:#66d9ef">function</span> add(<span style="color:#66d9ef">uint</span> _value) <span style="color:#66d9ef">public</span> {
        value <span style="color:#f92672">+=</span> _value;
    }
}

<span style="color:#66d9ef">contract</span> Subtraction <span style="color:#66d9ef">is</span> Storage {
    <span style="color:#66d9ef">function</span> sub(<span style="color:#66d9ef">uint</span> _value) <span style="color:#66d9ef">public</span> {
        value <span style="color:#f92672">-=</span> _value;
    }
}
</code></pre></div><p>If you are interested in learning about other proxy patterns, read the <a href="https://blog.openzeppelin.com/proxy-patterns/">fantastic article by OpenZeppelin</a>.</p>

</div></main>
</body>

</html>